<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A Category for Models ¬∑ SemanticModels</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SemanticModels</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">SemanticModels.jl</a></li><li><a class="toctext" href="../usecases/">Intended Use Cases</a></li><li><a class="toctext" href="../news/">News</a></li><li><a class="toctext" href="../modeltools/">ModelTools</a></li><li><a class="toctext" href="../example/">Example</a></li><li><a class="toctext" href="../theory/">Theory</a></li><li><a class="toctext" href="../dubstep/">Dubstep</a></li><li><a class="toctext" href="../graph/">Knowledge Graphs</a></li><li><a class="toctext" href="../extraction/">Knowledge Extraction</a></li><li><a class="toctext" href="../validation/">Validation</a></li><li><a class="toctext" href="../library/">Library Reference</a></li><li><a class="toctext" href="../approach/">Approaches</a></li><li><a class="toctext" href="../slides/">Slides</a></li><li><a class="toctext" href="../FluModel/">Flu Model</a></li><li><a class="toctext" href="../contributing/">Contributing</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>A Category for Models</a></li></ul><a class="edit-page" href="https://github.com/jpfairbanks/SemanticModels.jl/blob/master/doc/src/category.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>A Category for Models</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="A-Category-for-Models-1" href="#A-Category-for-Models-1">A Category for Models</a></h1><p>[]{.math .inline} Let [ùíû]{.math .inline} be the category of programs, where [<em>Ob</em>(ùíû)]{.math .inline} and [<em>Hom</em>(<em>S</em>,‚ÄÜ<em>T</em>)={<em>f</em>‚ÄÖ‚à£‚ÄÖ<em>f</em>(:‚ÄÑ:‚ÄÑ<em>S</em>):‚ÄÑ:‚ÄÑ<em>T</em>}]{.math .inline}. A model is a subcategory comprised of functions and types used in the code that implements that model. Then a model transformation is a function, [<em>t</em>]{.math .inline}, on models [<em>M</em>]{.math .inline} that induces a functor [<em>F</em>‚ÄÑ:‚ÄÑ<em>t</em>(<em>M</em>)‚Üí<em>M</em>]{.math .inline}. We define the model transformation as function on models because you need to compute it going from the simple model to the more complex model, but the functor goes the other way, from the complex model to the simple model.</p><h2><a class="nav-anchor" id="Properties-of-Transformations-1" href="#Properties-of-Transformations-1">Properties of Transformations</a></h2><p>Model transformations respect composition.</p><p><em>Proof:</em> If [<em>t</em>~1~(<em>M</em>)=<em>M</em>‚Ä≤]{.math .inline} there exists [<em>F</em>‚ÄÑ:‚ÄÑ<em>M</em>‚Ä≤‚Üí<em>M</em>]{.math .inline} and [<em>t</em>~2~(<em>M</em>‚Ä≤)‚ÄÑ=‚ÄÑ<em>M</em>‚Ä≥]{.math .inline} there exists [<em>G</em>‚ÄÑ:‚ÄÑ<em>M</em>‚Ä≥‚Üí<em>M</em>‚Ä≤]{.math .inline} then [<em>t</em>~2~‚ÄÖ‚àò‚ÄÖ<em>t</em>~1~]{.math .inline} induces a functor [<em>G</em>‚ÄÖ‚àò‚ÄÖ<em>F</em>‚ÄÑ:‚ÄÑ<em>M</em>‚Ä≥‚Üí<em>M</em>]{.math .inline} by the definition of functor.</p><h2><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h2><p>A simple model of gravity can be represented. Everyone knows the formula for the force of gravity, the sum of the masses divided by the double of the radius between them</p><p>[$F = G \frac{m_1 + m_2}{2r}$]{.math .inline}</p><p>Oh wait, that isn&#39;t right, it has that structure, but is it the sum or the product? And is twice the radius or the square of the radius?</p><p>A model transformation can recover the right model for us. The following figure show [<em>M</em>]{.math .inline} on the left and [<em>M</em>‚Ä≤]{.math .inline} on the right. The functor between them is shown using color.</p><p>gravity diagram</p><p>The functor from [<em>M</em>‚Ä≤]{.math .inline} to [<em>M</em>]{.math .inline} tells us how to transform [<em>M</em>‚Ä≤]{.math .inline} back into [<em>M</em>]{.math .inline}. We see that the only think that changed is [√ó]{.math .inline} becomes [+]{.math .inline} and [<em>sqr</em>]{.math .inline} becomes [<em>dbl</em>]{.math .inline}. This is exactly the way a programmer would describe the difference between these two models.</p><p>We can see the notion of a fully faithful functor indicating that these models have the same structure. The functions in these two programs are in 1-1 correspondence. The notion of fully faithful functors says that for every pair of types [<em>S</em>,‚ÄÜ<em>T</em>]{.math .inline} [<em>F</em>]{.math .inline} maps [<em>Hom</em>~<em>M</em>‚Ä≤~(<em>S</em>,‚ÄÜ<em>T</em>)]{.math .inline} to [<em>Hom</em>~<em>M</em>~(<em>F</em>(<em>S</em>),<em>F</em>(<em>T</em>))]{.math .inline} with a 1-1 function. For this case [<em>F</em>(<em>S</em>)=<em>S</em>]{.math .inline} for all types. So this reduces to [<em>Hom</em>~<em>M</em>‚Ä≤~(<em>S</em>,‚ÄÜ<em>T</em>)‚Üí<em>Hom</em>~<em>M</em>~(<em>S</em>,‚ÄÜ<em>T</em>)]{.math .inline} with a 1-1 function. Based on the sizes of the [<em>Hom</em>]{.math .inline} sets, we see that there are only 4 possible fully faithful functors between these two models. The most obvious one is the one shown with color.</p><h3><a class="nav-anchor" id="Isomorphism-is-too-strict-1" href="#Isomorphism-is-too-strict-1">Isomorphism is too strict</a></h3><p>You might think that since these diagrams look like graphs and the functors look like graph homomorphism, that graph isomorphism is a good definition of &quot;models with the same structure&quot;. But this is two strict.</p><p>In the following example the type graphs are not isomorphic, but there is a fully faithful functor between the model categories.</p><h2><a class="nav-anchor" id="A-category-of-models-1" href="#A-category-of-models-1">A category of models</a></h2><p>Let [‚Ñ≥‚Ñ¥ùíπ]{.math .inline} represent the category of models under transformation. [<em>Ob</em>(‚Ñ≥‚Ñ¥ùíπ)]{.math .inline} is the set of models and [<em>Hom</em>~‚Ñ≥‚Ñ¥ùíπ~(<em>M</em>‚Ä≤,<em>M</em>)]{.math .inline} is the set of functors from [<em>M</em>‚Ä≤]{.math .inline} to M (ie. transformations from [<em>M</em>]{.math .inline} to [<em>M</em>‚Ä≤]{.math .inline}).</p><h2><a class="nav-anchor" id="Perspective-on-Model-Selection-1" href="#Perspective-on-Model-Selection-1">Perspective on Model Selection</a></h2><p>Given an initial model [<em>M</em>]{.math .inline} a set of morphisms in [‚à™~<em>x</em>~<em>Hom</em>~‚Ñ≥‚Ñ¥ùíπ~(<em>M</em>,‚ÄÜ<em>x</em>)]{.math .inline} we want to pick the [<em>m</em>]{.math .inline} that minisimizes some function [‚Ñì(<em>m</em>)]{.math .inline} which is the loss between the data and the model [<em>m</em>]{.math .inline}. Suppose that [<em>T</em>‚ÄÑ=‚ÄÑ‚ü®<em>T</em>~<em>i</em>~‚ü©]{.math .inline} is the set of transformations generated by [{<em>T</em>~<em>i</em>~‚ÄÖ‚à£‚ÄÖ<em>i</em>‚ÄÑ‚àà‚ÄÑ‚Ñê}]{.math .inline}. We want to derive model selection algorithms that work for any [<em>M</em>,‚ÄÜ‚Ñì,‚ÄÜ<em>T</em>]{.math .inline}.</p><p>These algorithms will exploit the algebra of the transformation set, for example if the set of transformations is just a compositional monoid then the only option is to enumerate the tree of possible transformations [(<em>List</em>(<em>T</em>),‚ÄÖ+‚ÄÖ+,‚ÄÜ[])]{.math .inline} and pick the one that minimizes the loss. If the transformations have a stronger structure, such as forming a ring, and that structure is compatible with respect to the loss function, we should be able to find algorithms that exploit that structure.</p><footer><hr/></footer></article></body></html>
