<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Intended Use Cases · SemanticModels</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SemanticModels</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">SemanticModels.jl</a></li><li class="current"><a class="toctext" href>Intended Use Cases</a><ul class="internal"><li><a class="toctext" href="#Counterfactuals-1">Counterfactuals</a></li><li><a class="toctext" href="#Model-Code-Transformations-1">Model-Code Transformations</a></li><li><a class="toctext" href="#Use-Cases-1">Use Cases</a></li></ul></li><li><a class="toctext" href="../news/">News</a></li><li><a class="toctext" href="../modeltools/">ModelTools</a></li><li><a class="toctext" href="../example/">Example</a></li><li><a class="toctext" href="../theory/">Theory</a></li><li><a class="toctext" href="../dubstep/">Dubstep</a></li><li><a class="toctext" href="../graph/">Knowledge Graphs</a></li><li><a class="toctext" href="../extraction/">Knowledge Extraction</a></li><li><a class="toctext" href="../validation/">Validation</a></li><li><a class="toctext" href="../library/">Library Reference</a></li><li><a class="toctext" href="../approach/">Approaches</a></li><li><a class="toctext" href="../slides/">Slides</a></li><li><a class="toctext" href="../FluModel/">Flu Model</a></li><li><a class="toctext" href="../contributing/">Contributing</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Intended Use Cases</a></li></ul><a class="edit-page" href="https://github.com/jpfairbanks/SemanticModels.jl/blob/master/doc/src/usecases.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Intended Use Cases</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Intended-Use-Cases-1" href="#Intended-Use-Cases-1">Intended Use Cases</a></h1><p>Here are some use cases for SemanticModels.jl</p><p>Scientific knowledge is richer than the ability to make predictions given data. Knowledge and understanding provide the ability to reason about novel scenarios.  A crucial aspect of acquiring knowledge is asking questions about the world and answering those questions with models.</p><p>Suppose the model is  <span>$du/dt = f_p(u,t)$</span> where <span>$u$</span> is the observable, <span>$du/dt$</span> is the derivative, <span>$f$</span> is a function, <span>$t$</span> is the time variable, and <span>$p$</span> is a parameter. </p><p>Scientific knowledge involves asking and answering questions about the model. For example:</p><ol><li>How does <code>u</code> depend on <code>p</code>?</li><li>How does <code>u</code> depend on <code>f</code>?</li><li>How does <code>u</code> depend on the implementation of <code>f</code>?</li></ol><h2><a class="nav-anchor" id="Counterfactuals-1" href="#Counterfactuals-1">Counterfactuals</a></h2><p>Scientists often want to run counterfactuals through a model. they have questions like: </p><ol><li>What if the parameters were different?</li><li>What if the functional form of this equation was different?</li><li>What if the implementation of this function was different?</li></ol><p>The &quot;how&quot; questions can be answered by running counterfactuals of the model. In order to run counterfactuals we need to modify the code.  The current approach is for scientists to modify code writen by other scientists. This takes a long time and requires models to be converted from the modeling level to the code level,  then someone else reads the code and converts it back to the modeling level.</p><p>If we could automate these transformations, we could enable scientists to spend more time  thinking about the science and less time working with code. </p><h2><a class="nav-anchor" id="Model-Code-Transformations-1" href="#Model-Code-Transformations-1">Model-Code Transformations</a></h2><p>There are many places we could modify code in order to give it new features for modeling.</p><ol><li>Source Code, changing the source files on disk before they are parsed</li><li>Expressions, after parsing, we could use macros or Meta.parse to get <code>Expr</code>s and make new ones to <code>eval</code></li><li>Type System, using multiple dispatch with new types to get new behavior</li><li>Overdubbing, Cassette.jl lets you change the definitions of functions with overdub</li><li>Contextual Tags, Cassette provides a tagging mechanism attach metadata to values</li><li>Compiler Pass, Cassette lets you implement your own compiler passes</li></ol><p>Different code modifications will be easier at different levels of this toolchain.</p><h2><a class="nav-anchor" id="Use-Cases-1" href="#Use-Cases-1">Use Cases</a></h2><ol><li>Answering counterfactuals</li><li>Instrumenting code to extract additional insight</li><li>Semantic Model Validation</li></ol><h3><a class="nav-anchor" id="Answering-Counterfactuals-1" href="#Answering-Counterfactuals-1">Answering Counterfactuals</a></h3><p>Scientists want to change 1) parameters, 2) assumptions, 3) functions, or</p><ol><li>implementations in order to determine their effects on the output of the model.</li></ol><p>Note: a paramter is an argument to the model and is intended (by the simulation author) to be changed by users. An assumption is a value in the code that could be changed, but is not exposed to the API.</p><p>While making accurate predictions of measurable phenomena is a necessary condition of a scientific knowledge it is not sufficient. Scientists have knowledge that allows them to reason about novel scenarios and they do this by speculating about counterfactuals. Thus answering counterfactuals about model codes form a foundational capability of our system.</p><h3><a class="nav-anchor" id="Instrumenting-Model-Code-1" href="#Instrumenting-Model-Code-1">Instrumenting Model Code</a></h3><p>In order to get additional insight out of models, we want to add instrumentation into the bodies of the functions. These instrumented values will be useful for many purposes. The simplest use is to add instrumentation of additional measurements. Scientists write code for a specific purposes and do not take the time to report all possible measurements or statistics in their code. A second scientist who is trying to repurpose that software will often need to compute different values from the internal state of the algorithm in order to understand their phenomenon of interest.</p><p>A simple example is a model that simulates Lotka-Volterra population dynamics and reports the average time between local maxima of predator populations. A second scientist might want to also characterize the variance or median of the time between local maxima.</p><h3><a class="nav-anchor" id="Semantic-Model-Validation-1" href="#Semantic-Model-Validation-1">Semantic Model Validation</a></h3><p>One could trace the value of variables as the code  is run in order to build up a distribution of <em>normal</em> values that variable takes. This could be used to learn implied invariants in the code. Then when running the model in a new context, you could compare the instrumentation values to these invariants to validate if the model is working as intended in this new context.</p><p>One of the main benefits of mechanistic modeling over statistical modeling is the generalization of mechanistic models to novel scenarios. It is difficult to determine when a model is being applied in a novel scenario where we can trust the output and a novel scenario that is beyond the bounds of the model&#39;s capability. By analyzing the values of the internal variables in the algorithms, we can determine whether a component of the model is operating outside of the region of inputs where it can be trusted.</p><p>An example of this validation could be constructed by taking a model that uses a polynomial approximation to compute a function <span>$f(x)$</span>. If this polynomial approximation has small error on a region of the input space, <span>$R$</span> then whenever <span>$x$</span> is in <span>$R$</span>, we can trust the model. But if we every run the model and evaluate the approximation on an <span>$x$</span> outside of this region, we do not know if the approximation is close, and cannot trust the model. Program analysis can help scientists to identify reasons to be sceptical of model validity.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">SemanticModels.jl</span></a><a class="next" href="../news/"><span class="direction">Next</span><span class="title">News</span></a></footer></article></body></html>
